<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Склад — обробка замовлень</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b1020;
      --card: #141a2e;
      --ring: #24304f;
      --txt: #e7eefc;
      --muted: #aab6d3;
      --accent: #5da9ff;
      --ok: #26c281;       /* зелений — Доставка */
      --warn: #ffd166;     /* жовтий — Самовивіз */
      --info: #3b82f6;     /* синій — Відправка */
    }
    html,body{height:100%}
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--txt);
      background: radial-gradient(1200px 600px at 50% -10%, #162040, var(--bg));
    }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 24px 16px 40px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom: 18px; flex-wrap: wrap; }
    .title { font-weight: 700; letter-spacing: .2px; display:flex; gap:10px; align-items:center; }
    .title span { opacity:.9 }
    .controls { display:flex; gap:10px; align-items:center; }
    button {
      background: var(--accent);
      color: #06203d;
      border: none; border-radius: 12px;
      padding: 10px 14px;
      font-weight: 600; cursor: pointer;
      box-shadow: 0 8px 20px rgba(93,169,255,.25);
    }
    button:active { transform: translateY(1px); }
    .stamp { color: var(--muted); font-size: 14px; }
    .grid { display:grid; grid-template-columns: repeat(3, minmax(220px,1fr)); gap: 16px; }
    @media (max-width: 860px) { .grid { grid-template-columns: 1fr; } }
    .card {
      background: linear-gradient(180deg, #141a2e, #11182b);
      border: 1px solid #1d2540;
      border-radius: 20px;
      padding: 16px 16px 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .labelRow { display:flex; align-items:center; justify-content:space-between; margin-bottom: 6px; }
    .label { font-weight: 650; color: #dbe6ff; }
    .total { color: var(--muted); font-weight:600; }
    .chartBox { position: relative; width: 100%; aspect-ratio: 1 / 1; }
    .error {
      margin-top: 10px; padding: 10px 12px;
      border: 1px solid #4f1f2a; background: #2a1220; color: #ffd1db;
      border-radius: 12px; display:none;
    }
    footer { margin-top: 18px; color: var(--muted); font-size: 13px; text-align: center; opacity: .85; }

    /* --- Login overlay --- */
    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(3,8,20,.6); backdrop-filter: blur(3px); z-index: 50;
    }
    .login {
      width: min(92vw, 360px);
      background: #0f1629; border: 1px solid #1d2540; border-radius: 16px;
      padding: 18px; box-shadow: 0 20px 50px rgba(0,0,0,.35);
    }
    .login h3 { margin: 0 0 10px; font-size: 18px; }
    .login label { display:block; font-size: 13px; color: var(--muted); margin: 8px 0 6px; }
    .login input {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #253052;
      background: #0b1225; color: var(--txt);
    }
    .login .row { display:flex; gap:10px; margin-top: 14px; align-items:center; }
    .login .msg { color:#ffd1db; font-size: 13px; display:none; }
    .login button { width: 100%; }
  </style>
</head>
<body>
  <div class="overlay" id="authOverlay" hidden>
    <div class="login">
      <h3>Вхід</h3>
      <label>Логін</label>
      <input id="loginUser" autocomplete="username" />
      <label>Пароль</label>
      <input id="loginPass" type="password" autocomplete="current-password" />
      <div class="row">
        <div class="msg" id="authMsg">Невірний логін або пароль</div>
      </div>
      <div class="row">
        <button id="loginBtn" type="button">Увійти</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <header>
      <div class="title">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83" stroke="#5da9ff" stroke-width="1.6" stroke-linecap="round"/></svg>
        <span>Склад — опрацювання замовлень (7 днів)</span>
      </div>
      <div class="controls">
        <div class="stamp" id="stamp">оновлюю…</div>
        <button id="refreshBtn" type="button">Оновити</button>
      </div>
    </header>

    <div class="grid" id="grid"><!-- cards will be injected --></div>

    <div class="error" id="errorBox"></div>
    <footer>Автооновлення раз на 300 с • Джерело: платформа VETAi</footer>
  </div>

  <script>
    // ---------------- SETTINGS ----------------
    const WEBHOOK_URL = "https://n8n.vetai.win/webhook/da346a7b-9591-46a4-8bd7-e4b150dea063";
    // META_URL повинен віддавати { authUser: "...", authPass: "..." } з ноди dataIn
    const META_URL   = "https://n8n.vetai.win/webhook/meta-auth-and-hours"; // створіть легкий ендпойнт у n8n
    const STATUS_KEYS = ["Відправлено на склад", "Збирається", "Зібрано"];
    const COLORS = {
      "Відправка": "#3b82f6",  // синій
      "Самовивіз": "#ffd166",  // жовтий
      "Доставка":  "#26c281"   // зелений
    };
    const WORK_START_H = 8;
    const WORK_END_H   = 21;
    const MIN_FETCH_INTERVAL_MS = 300_000;

    // запасні логін/пароль, якщо META_URL недоступний (замініть на деплої)
    let AUTH = { user: "data", pass: "30102020" };

    // --------- Center text plugin (К/О) ----------
    const CenterText = {
      id: 'centerText',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const {ctx, chartArea: {width, height}} = chart;
        const meta = chart.getDatasetMeta(0);
        if (!meta || !meta.data || !meta.data[0]) return;
        const x = meta.data[0].x;
        const y = meta.data[0].y;

        ctx.save();
        const text = chart.$center || '0 / 0';
        ctx.font = `700 ${Math.max(20, width * 0.11)}px system-ui, -apple-system, Segoe UI, Roboto`;
        ctx.fillStyle = '#e7eefc';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x, y);

        ctx.font = `500 ${Math.max(10, width * 0.045)}px system-ui, -apple-system, Segoe UI, Roboto`;
        ctx.fillStyle = '#aab6d3';
        ctx.fillText('К / О', x, y + (height * 0.16));
        ctx.restore();
      }
    };
    Chart.register(CenterText);

    // --------- UI bits ----------
    const grid = document.getElementById('grid');
    const cards = {}; // statusKey -> { chart, titleEl, totalEl }

    function makeCard(statusKey) {
      const card = document.createElement('div');
      card.className = 'card';

      const row = document.createElement('div');
      row.className = 'labelRow';

      const title = document.createElement('div');
      title.className = 'label';
      title.textContent = statusKey;

      const total = document.createElement('div');
      total.className = 'total';
      total.textContent = '0'; // оновимо

      row.appendChild(title);
      row.appendChild(total);
      card.appendChild(row);

      const box = document.createElement('div');
      box.className = 'chartBox';
      const canvas = document.createElement('canvas');
      box.appendChild(canvas);
      card.appendChild(box);

      const chart = new Chart(canvas.getContext('2d'), {
        type: 'doughnut',
        data: {
          labels: ['Відправка','Самовивіз','Доставка'],
          datasets: [{
            label: 'Всего (К+О)',
            data: [0, 0, 0],
            backgroundColor: [COLORS['Відправка'], COLORS['Самовивіз'], COLORS['Доставка']],
            borderWidth: 0,
            hoverOffset: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '68%',
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: '#cfe0ff',
                usePointStyle: true,
                generateLabels(c) {
                  const d = c.data.datasets[0].data;
                  const labels = c.data.labels;
                  return labels.map((lbl, i) => ({
                    text: `${lbl}: ${d[i] ?? 0}`,
                    fillStyle: c.data.datasets[0].backgroundColor[i],
                    strokeStyle: 'transparent',
                    lineWidth: 0
                  }));
                }
              }
            },
            tooltip: {
              callbacks: {
                label(ctx) {
                  const lbl = ctx.label;
                  const val = ctx.parsed;
                  const meta = ctx.chart.$breakdown || {};
                  const k = meta.K?.[lbl] ?? 0;
                  const o = meta.O?.[lbl] ?? 0;
                  return `${lbl}: ${val} (К ${k} / О ${o})`;
                }
              }
            }
          }
        },
        plugins: [CenterText]
      });

      grid.appendChild(card);
      cards[statusKey] = { chart, titleEl: title, totalEl: total };
    }

    STATUS_KEYS.forEach(makeCard);

    // ---------- helpers ----------
    const stampEl = document.getElementById('stamp');
    const errorBox = document.getElementById('errorBox');
    function setStamp(date = new Date()) {
      const two = n => n.toString().padStart(2, '0');
      const t = `${two(date.getHours())}:${two(date.getMinutes())}:${two(date.getSeconds())}`;
      stampEl.textContent = `оновлено о ${t}`;
    }
    function showError(msg) {
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
    }
    function clearError() {
      errorBox.style.display = 'none';
      errorBox.textContent = '';
    }
    const inWorkHours = (d = new Date()) => {
      const h = d.getHours();
      return h >= WORK_START_H && h < WORK_END_H;
    };

    // нормалізуємо об’єкт одного статусу до очікуваних ключів
    const normalizeStatusName = (s) => {
      if (!s) return s;
      // прибираємо можливі "(скл.)", "(склад)" тощо:
      return String(s).replace(/\s*\(.*?\)\s*$/,'');
    };
    const mapDeliveryKey = (raw) => {
      const s = String(raw || '').toLowerCase();
      if (s.includes('пункт') || s.includes('відправ')) return 'Відправка';
      if (s.includes('самов')) return 'Самовивіз';
      return 'Доставка';
    };

    // ---------- AUTH ----------
    const overlay = document.getElementById('authOverlay');
    const loginBtn = document.getElementById('loginBtn');
    const loginUser = document.getElementById('loginUser');
    const loginPass = document.getElementById('loginPass');
    const authMsg   = document.getElementById('authMsg');

    function openAuth() { overlay.hidden = false; authMsg.style.display = 'none'; }
    function closeAuth() { overlay.hidden = true; }

    function tryLogin() {
      const u = loginUser.value.trim();
      const p = loginPass.value;
      if (u === AUTH.user && p === AUTH.pass) {
        localStorage.setItem('warehouse_auth', JSON.stringify({u, at: Date.now()}));
        closeAuth();
        initAfterAuth();
      } else {
        authMsg.style.display = 'block';
      }
    }
    loginBtn.addEventListener('click', tryLogin);
    loginPass.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') tryLogin(); });

    async function loadMetaAuth() {
      try {
        const res = await fetch(META_URL, { method: 'GET' });
        if (res.ok) {
          const meta = await res.json();
          if (meta?.authUser && meta?.authPass) AUTH = { user: meta.authUser, pass: meta.authPass };
        }
      } catch (_e) {
        // тихо ігноруємо — використовуються FALLBACK креденшали
      }
    }

    // ---------- DATA (with throttling + work-hours policy) ----------
    const LS_KEY = 'warehouse_status_cache_v2';
    const LS_AT  = 'warehouse_status_cache_at_v2';
    let lastFetchAt = 0;

    function getCache() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        const at  = Number(localStorage.getItem(LS_AT) || 0);
        if (!raw) return null;
        const data = JSON.parse(raw);
        return { data, at };
      } catch { return null; }
    }
    function setCache(data) {
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(data));
        const now = Date.now();
        localStorage.setItem(LS_AT, String(now));
        lastFetchAt = now;
      } catch {}
    }

    function aggregateForChart(row) {
      // формуємо сумарні по кожному способу (К+О) та зберігаємо для тултіпів К/О
      const K = row?.К || {};
      const O = row?.О || {};
      const delKeys = ['Відправка','Самовивіз','Доставка'];

      const totals = {};
      const breakdown = { K:{}, O:{} };
      for (const k of delKeys) {
        const kv = Number(K[k] || 0);
        const ov = Number(O[k] || 0);
        totals[k] = kv + ov;
        breakdown.K[k] = kv;
        breakdown.O[k] = ov;
      }
      return { totals, breakdown };
    }

    function applyToCharts(serverRows) {
      // serverRows: [{Статус, Всього, К:{...}, О:{...}}, ...]
      STATUS_KEYS.forEach(statusKey => {
        // знайти відповідний рядок, ураховуючи нормалізацію
        const row = serverRows.find(r => normalizeStatusName(r?.Статус) === statusKey);
        const { chart, titleEl, totalEl } = cards[statusKey];
        if (!row) {
          chart.data.datasets[0].data = [0,0,0];
          chart.$center = `0 / 0`;
          chart.$breakdown = {K:{}, O:{}};
          chart.update();
          titleEl.textContent = statusKey;
          totalEl.textContent = '0';
          return;
        }

        // обчислення
        const kTotal = Number(row?.К?.total || 0);
        const oTotal = Number(row?.О?.total || 0);
        const grand  = Number(row?.Всього || (kTotal + oTotal));

        const { totals, breakdown } = aggregateForChart(row);

        // мапимо у фіксований порядок сегментів
        const dataArr = ['Відправка','Самовивіз','Доставка'].map(k => totals[k] || 0);

        chart.data.datasets[0].data = dataArr;
        chart.$center = `${kTotal} / ${oTotal}`;
        chart.$breakdown = breakdown;
        chart.update();

        // заголовок + кількість
        titleEl.textContent = statusKey;
        totalEl.textContent = String(grand);
      });
    }

    async function fetchServerData() {
      const res = await fetch(WEBHOOK_URL, { method: 'GET' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const payload = await res.json();
      return Array.isArray(payload) ? payload : [payload];
    }

    async function loadData() {
      clearError();
      const now = Date.now();

      // тротлінг
      if (now - lastFetchAt < MIN_FETCH_INTERVAL_MS) {
        const cache = getCache();
        if (cache?.data) {
          applyToCharts(cache.data);
          setStamp(new Date(cache.at));
          return;
        }
        // якщо кеша нема — все одно підемо у мережу (перший раз)
      }

      // політика робочих годин
      if (!inWorkHours(new Date())) {
        const cache = getCache();
        if (cache?.data) {
          applyToCharts(cache.data);
          setStamp(new Date(cache.at));
          return;
        }
        // якщо кеша нема — один мережевий запит, щоб щось зберегти
      }

      stampEl.textContent = 'оновлюю…';

      try {
        const data = await fetchServerData();
        setCache(data);
        applyToCharts(data);
        setStamp(new Date());
      } catch (err) {
        const cache = getCache();
        if (cache?.data) {
          applyToCharts(cache.data);
          setStamp(new Date(cache.at));
        }
        showError('Не вдалося оновити дані. Показано останній кеш. Деталі: ' + (err?.message || err));
      }
    }

    // ---------- bootstrap ----------
    async function initAfterAuth() {
      document.getElementById('refreshBtn').addEventListener('click', loadData);
      await loadData();
      setInterval(loadData, MIN_FETCH_INTERVAL_MS); // автооновлення раз на 5 хвилин
    }

    (async function bootstrap() {
      await loadMetaAuth();
      const saved = localStorage.getItem('warehouse_auth');
      if (saved) {
        try {
          const obj = JSON.parse(saved);
          if (obj?.u === AUTH.user) {
            closeAuth();
            initAfterAuth();
            return;
          }
        } catch {}
      }
      openAuth();
    })();
  </script>
</body>
</html>
